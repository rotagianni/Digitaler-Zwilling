<!DOCTYPE html>
<html>
<head>
    <title>Digitaler Zwilling eines Fischertechnik Roboterss</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="body-filter">
     
        <header>
            <h1 id="title">Digitaler Zwilling <br>eines Fischertechnik Roboters</h1>
            <nav>
                <ul class="nav_links">
                    <li><a href="index.html">Home</a></li>
                    <li><a href="simulation.html">Simulation</a></li>
                    <li><a href="information.html">Informationen</a></li>
                    <li><a href="#">Team</a></li>
                </ul>
            </nav>
        </header>
        <script type="text/javascript">
            window.addEventListener("scroll", function(){
                var header = document.querySelector("header");
                header.classList.toggle("sticky", window.scrollY > 0);
                var title = document.getElementById("title");
                if(window.scrollY > 0){
                title.innerHTML = "Digitaler Zwilling eines Fischertechnik Roboters";
                } else {
                    title.innerHTML = "Digitaler Zwilling <br>eines Fischertechnik Roboters";
                }
            })
        </script>

        <div class="spacer"></div>

        <div class="wrap-collabsible">
            <input id="collapsible1" class="toggle" type="checkbox">
            <label for="collapsible1" class="lbl-toggle">
                <div class="collapsible-title">
                    Analysephase
                </div>
                <div class="collapsible-title-image">
                    <img src="pictures/analysis.jpg"alt="">
                </div>

            </label>
            <div class="collapsible-content">
              <div class="content-inner">
                <p>Zu Beginn des Projekts haben wir uns gemeinsam als Team zusammengesetzt und besprochen wie wir an dieses Projekt herangehen möchten. Relativ zügig sind wir zu dem Schluss gekommen, dass wir das Projekt in drei große Phasen einteilen werden. Die Analyse-, Implementierungs- und die Integrationsphase.
                    <br>
                    In der Analysephase geht es besonders darum, alle nötigen Anforderungen zu formulieren, um mit der Softwareentwicklung beginnen zu können. Die einzelnen Themenbereiche werden nun detaillierter erläutert. </p>
                    <br> <hr> <br>
                    <p>Einer der ersten Aufgaben die Anstand, war das zuteilen von gewissen Arbeitspaketen und entsprechenden Verantwortlichkeiten. Dazu haben wir uns überlegt welche möglichen Arbeitsbereiche und Aufgaben es in diesem Projekt gibt und wer sich auf welches Thema spezialisiert. Erarbeitet haben wir uns dabei vorerst die Arbeitsbereiche wie in der Tabelle zu sehen.
                    <br>
                    Anschließend haben wir darüber gesprochen wer sich was zutraut, in welchen Bereichen jeder seine Stärken und Schwächen hat und wo vielleicht jemand schon mehr Erfahrung gesammelt hat im Vergleich zu anderen. Anhand dessen haben wir die Hauptverantwortlichen den beschlossenen Arbeitsbereichen folgendermaßen zugeteilt: </p>
              </div>
            </div>
          </div>

          <div class="wrap-collabsible">
            <input id="collapsible2" class="toggle" type="checkbox">
            <label for="collapsible2" class="lbl-toggle">
                <div class="collapsible-title">
                    3D Simulation
                </div>
                <div class="collapsible-title-image">
                    <img src="pictures/3dm.jpg"  style="transform: translateY(-58px);" alt="">
                </div>

            </label>
            <div class="collapsible-content">
              <div class="content-inner">
                  <h2>Modellieren der Bauteile in Fusion 360</h2>
                  <hr>
                  <div class="content-chapter">
                      <p>Zu Beginn musste jedes Bauteil des realen Roboters erst einmal modelliert werden, um ein exaktes Replika als 3D-Modell erstellen zu können. Glücklicherweise hatten wir die Gelegenheit viele 3D-Modelle der Fischertechnik Bauteile aus einem anderen Programm zu exportieren, so dass wir nur sehr wenige mithilfe des Programms Fusion 360 selbst erstellen mussten.</p>
                      <div class="content-image">
                          <img src="pictures/info/fusion360.gif" style="transform: translateX(-10px); width: inherit;" alt="">
                        </div>
                    </div>
                  <br> <br>
                  <h2>Zusammensetzen der Bauteile in Blender</h2>
                  <hr>
                  <div class="content-chapter">
                      <p>Die modellierten Bauteile wurden danach in dem populären 3D-Modellierungs-Programm Blender zusammengesetzt. Unter anderem konnten zusammengehörige Bauteilgruppen bereits hier gruppiert und jedem Bauteil eine passende Textur oder ein passendes Material verpasst werden. 
                    </p>
                    <div class="content-image">
                        <img src="pictures/info/blender.jpg" style="transform: translateX(0px); width: inherit;" alt="">
                      </div>
                </div>
                  <br> <br>
                  <h2>Importieren des 3D-Modells in Unity</h2>
                  <hr>
                  <div class="content-chapter">
                      <p>Das 3D-Modell des Fischertechnik Vakuum-Sauggreifers sieht nach der Fertigstellung in Blender bereits sehr gut aus. Doch um den Roboter auch steuern zu können, muss das 3D-Modell in Unity importiert werden. In Unity ist es möglich die weitverbreitetsten 3D-Modell Dateiformate ohne Probleme zu importieren. So auch das zuvor erstellte Blenderprojekt des Roboters.
                    <div class="content-image">
                        <img src="pictures/import3d.jpg" style="transform: translateX(0px); width: inherit;" alt="">
                        </div>
                </div>
                  </p>
                  <br> <br>
                  <h2>Entwickeln der Ansteuerbarkeit des Roboters</h2>
                  <hr>
                  <p>In Unity ist es relativ einfach die bereits in Blender hergestellten Beziehungen - zum Beispiel zwischen Zahnrädern - in Bewegung zu setzen und zu simulieren. Den einzelnen Komponenten kann man C# Skripte zuweisen, die so ziemlich alles kontrollieren können. Um die spätere Ansteuerbarkeit durch externe Java-Programme und betätigte Buttons zu ermöglichen, mussten entsprechende Schnittstellen bereitgestellt werden, die Bewegungsbefehle an Motoren und Sensoren weiterleiten.
                  </p>
                  <br> <br>
                  <h2>Modellieren der Umgebung</h2>
                  <hr>
                  <div class="content-chapter">
                      <p>Um die Umstände in denen sich der Roboter in einer realen Situation befinden würde noch besser zu simulieren sollte natürlich auch die unmittelbare Umgebung modelliert werden. In der Hochschule wären das noch weitere Fischertechnik-Roboter der Fischertechnik-Fabrik gewesen. Damit jeder dieser Roboter nicht einzeln modelliert werden muss, haben wir uns für eine modernere Variante entschieden, um ein 3D-Modell der Umgebung zu erzeugen. Und zwar eine Methode mit der sich ein 3D-Modell aus vielen Fotos des zu modellierenden Objekts konstruieren lässt.
                    </p>
                    <div class="content-image">
                        <img src="pictures/env3d.jpg" style="transform: translateX(0px); width: inherit;" alt="">
                    </div>
                </div>
                  <br> <br>
              </div>
            </div>
          </div>

          <div class="wrap-collabsible">
            <input id="collapsible3" class="toggle" type="checkbox">
            <label for="collapsible3" class="lbl-toggle">
                <div class="collapsible-title">
                    User Interface Design
                </div>
                <div class="collapsible-title-image">
                    <img src="pictures/ui22.jpg.jpeg" style="transform: translateY(-80px);" alt="">
                </div>

            </label>
            <div class="collapsible-content">
              <div class="content-inner">
                <h2>Mockup</h2>
                <hr>
                <div class="content-chapter">
                    <p>Jede gute Software braucht selbstverständlich auch eine schöne Benutzeroberfläche. Um nicht einfach drauflos zu entwickeln ohne zu wissen was am Ende dabei herauskommt und ob damit überhaupt irgendjemand etwas anfangen kann, haben wir zuerst einen Prototypen erstellt. Dieser Prototyp stellt ein Konzept dar, welches die gewünschten Anforderungen erfüllen soll. Wird dieses Konzept vom Kunde akzeptiert, kann es an die Implementierung gehen.
                    </p>
                    <div class="content-image">
                        <img src="pictures/env3d.jpg" style="transform: translateX(0px); width: inherit;" alt="">
                    </div>
                </div>
                <br> <br>
                <h2>Implementierung</h2>
                <hr>
                <p>Entwickelt haben wir die Benutzeroberfläche in Unity. Diese 3D-Engine ist nicht nur hervorragend dafür geeignet das 3D-Modell des Roboters anzuzeigen und zu simulieren sondern auch um eine dazu passende UI zu erstellen. Denn Unity bietet standardmäßig einige Komponenten und dazugehörige Einstellungen an, um das entwickeln einer Benutzeroberfläche möglichst einfach zu gestalten. <br> <br>
                </p>
                <br> <br>
                <h2>Java-Programm Steuerung</h2>
                <hr>
                <div class="content-chapter">
                    <p>Damit der Benutzer der Software in der Lage ist sich mit seinem Java-Programm zu verbinden, benötigt er die IP-Adresse, zu der er sich verbinden soll. Deshalb muss einen kleinen Ausschnitt in der UI geben, der diese Anzeigt und auch den aktuellen Status also ob eine Verbindung zu einem Java-Programm besteht. Außerdem sollen alle anderen UI-Elemente nicht nutzbar sein solange der Roboter durch ein solches Programm gesteuert wird.
                    </p>
                    <div class="content-image">
                        <img src="pictures/info/ipinfo.jpeg" style="transform: translateX(0px); width: inherit;" alt="">
                    </div>
                </div>
                <br> <br>
                <h2>Manueller Modus</h2>
                <hr>
                    <p>Der Manuelle Modus soll es dem Benutzer ermöglichen den Roboter auch ohne ein externes Programm steuern zu können. Deshalb bietet die Benutzeroberfläche eine zwei Schnittstellen, um den Roboter manuell ansteuern zu können.
                    <br> <br>  
                    Die erste sehr einfache Variante erlaubt es den Roboter per Buttons in allen drei Dimensionen bewegen zu können. Dabei wird die entsprechende Bewegung solange ausgeführt, wie der Benutzer den jeweiligen Button gedrückt hält.</p>
                    
                    <p>
                        <br> <br>
                        Wer stattdessen eine etwas spezifischere Bewegung ausführen möchte, der hat die Möglichkeit je Bewegungsachse die gewünschte Distanz und Geschwindigkeit festzulegen.
                        <br> <br>
                        Bei noch höheren Ansprüchen bleibt dem Benutzer nichts anderes übrig als ein externes Programm zu schreiben, dass der Roboter abarbeiten soll. 
                    </p>
                <div class="content-chapter">
                    <div class="content-image"  style="height: min-content; width: min-content;">
                        <img src="pictures/info/buttonsman.jpeg" style="transform: translateX(0px); scale: 1; width: 100%; height: 100%;" alt="">
                    </div>
                    <div class="content-image" style="height: min-content; width: min-content;">
                        <img src="pictures/info/codeeingabe.jpeg" style="transform: translateX(0px); width: inherit;" alt="">
                    </div>  
                </div>
                <br> <br>
                <h2>Live Protokoll</h2>
                <hr>
                <div class="content-chapter">
                    <p>Für manche Benutzer mag es auch wichtig sein detailliertere Informationen über die bestehenden Vorgänge des Roboters einsehen zu können. Auch das ermöglichen wir dem Benutzer indem die Protokoll-Daten nicht nur in eine Datei geschrieben sondern auch auf Wunsch in der UI angezeigt werden.
                    </p>
                    <div class="content-image">
                        <img src="pictures/info/liveprot.jpeg" style="transform: translate(-20px, -15px); width: inherit;" alt="">
                    </div>
                </div>
                <br> <br>
            </div>
            </div>
          </div>

          <div class="wrap-collabsible">
            <input id="collapsible8" class="toggle" type="checkbox">
            <label for="collapsible8" class="lbl-toggle">
                <div class="collapsible-title">
                    Ansteuerung des Roboters
                </div>
                <div class="collapsible-title-image">
                    <img src="pictures/txt.jpg" style="transform: translateY(-65px);" alt="">
                </div>

            </label>
            <div class="collapsible-content">
              <div class="content-inner">
                <h2>Replizieren des Kommunikationsprotokolls</h2>
                <hr>
                <p>Der reale Fischertechnik-Vakuumsauggreifer wird über ein spezielles Kommunikationsprotokoll angesteuert. Damit es keinen Unterschied für den Benutzer macht ob er den realen oder den digitalen Zwilling ansteuert, muss das reale Kommunikationsprotokoll des Roboters digital exakt repliziert werden. Dazu musste das reale Protokoll erstmal genauer analysiert und verstanden werden, da Fischertechnik keine besonders detaillierte Beschreibung zu dem Aufbau des Protokolls freigegeben hat.
                </p>
                <br> <br>
                <h2>Aufbauen einer TCP-Verbindung</h2>
                <hr>
                <p>Damit überhaupt irgendeine Art von Kommunikation stattfinden kann, muss zwischen dem Programm des Benutzers und unserer zu entwickelnden Software eine Verbindung aufgebaut werden. Für das dauerhafte versenden von Nachrichten baut man am besten eine konstante Verbindung auf. Das wird üblicherweise über das sehr populäre TCP-Protokoll erreicht. Für diesen Ansatz haben auch wir uns entschieden, um eine kontinuierliche Übertragung von Daten zu gewährleisten.
                </p>
                <br> <br>
                <h2>Befehlsinterpretation und Weitergabe</h2>
                <hr>
                <p>Die versendeten Nachrichten und Befehle müssen selbstverständlich auch korrekt interpretiert und dementsprechend an die Motoren und Sensoren des Roboters gesendet werden, um dort zur Ausführung zu kommen. Dafür wurde eine Schnittstelle entwickelt, die sämtlichen Befehlsverkehr regelt und für alle anderen Komponenten leicht zugänglich und ansprechbar ist.
                </p>
                <br> <br>
                </div>
            </div>
          </div>

          <div class="wrap-collabsible">
            <input id="collapsible5" class="toggle" type="checkbox">
            <label for="collapsible5" class="lbl-toggle">
                <div class="collapsible-title">
                    Kollisionserkennung
                </div>
                <div class="collapsible-title-image">
                    <img src="pictures/kollision.jpeg" alt="">
                </div>

            </label>
            <div class="collapsible-content">
              <div class="content-inner">
                <h2>Kollisionsboxen erstellen</h2>
                <hr>
                <p>Bevor Kollisionen jeglicher Art erkannt werden können müssen auf die Bauteile oder Bauteilgruppen Kollisionsboxen gelegt werden. Das ist eine von Unity bereitgestellt Funktion, die es ermöglicht das Verhalten der Kollisionsboxen untereinander zu steuern. Diese Kollisionsboxen umrahmen in etwa das kollidierende Bauteil und repräsentieren seine Form.
                </p>
                <br> <br>
                <h2>Erkennen von erwarteten und unerwarteten Kollisionen</h2>
                <hr>
                <p>Mithilfe der Kollisionsboxen kann nun bestimmt werden welche Bauteile und wie sie miteinander kollidieren. Diese auftretenden Kollisionen, sowohl mit dem Roboters selbst als auch mit der Umgebung, können nun erkannt werden. Was geschieht wenn eine Kollision erkannt wird und wie weiter verfahren werden soll kann durch C# Skripte festgelegt werden. 
                </p>
                <br> <br>
                <h2>Kollisions Kamera- und Informationssystem</h2>
                <hr>
                <p>Damit die auftretenden Kollisionen nicht untergehen sondern darauf hingewiesen wird, wurde ein Kamera- und Informationssystem entwickelt. Dieses zeigt dem Benutzer bei einer Kollision an wo und zwischen welchen Bauteilen sie aufgetreten ist.
                </p>
                <br> <br>
            </div>
            </div>
          </div>

          <div class="wrap-collabsible">
            <input id="collapsible6" class="toggle" type="checkbox">
            <label for="collapsible6" class="lbl-toggle">
                <div class="collapsible-title">
                    Protokollierung / Logger
                </div>
                <div class="collapsible-title-image">
                    <img src="pictures/logger.png" alt="">
                </div>

            </label>
            <div class="collapsible-content">
              <div class="content-inner">
                <h2>Schnittstelle für Logging</h2>
                <hr>
                <p>Bei Fehlerfällen ist es hilfreich nachvollziehen zu können welche Befehle der Roboter ausgeführt hat. Und auch während der Ausführung eines Programms kann es hilfreich sein zu sehen, was genau der Fischertechnik-Vakuumsauggreifer im Moment tut. Deshalb haben wir uns dazu entschieden ein Protokoll sowohl als Textdatei als auch in Echtzeit in der Benutzeroberfläche anzuzeigen. <br>
                Dazu musste eine Schnittstelle bereitgestellt werden, auf die von verschiedenen Stellen der Software aus zugegriffen und Informationen protokolliert werden können.<br>
                Die Schnittstelle stellt mehrere Methoden zur Verfügung, die im Grunde mit den zu protokollierenden Daten und dem Protokollierungslevel aufgerufen werden können. Das Protokollierungslevel legt die Art der Information fest. Dadruch kann man entweder nach speziellen Informationen filtern oder definieren welche Informationen protokolliert weden sollen.</p>
                <br> <br>
                <h2>Live Protokoll</h2>
                <hr>
                <p>Das Live- oder Echtzeitprotokoll ist lediglich eine Ausgabe der letzten Protokollinformationen in der Benutzeroberfläche, die es ermöglicht zur Laufzeit eines Programms genauer einzusehen welche Motoren und Sensoren angesprochen werden.
                </p>
                <br> <br>
            </div>
            </div>
          </div>

          <div class="wrap-collabsible">
            <input id="collapsible7" class="toggle" type="checkbox">
            <label for="collapsible7" class="lbl-toggle">
                <div class="collapsible-title">
                    Dokumentation
                </div>
                <div class="collapsible-title-image">
                    <img src="pictures/gantt.PNG" style="transform: translateY(-65px);" alt="">
                </div>

            </label>
            <div class="collapsible-content">
              <div class="content-inner">
                <h2>Pflichtenheft und Abschlussbericht</h2>
                <hr>
                <p>Für jedes anstehende Softwareprojekt ist es notwendig ein Pflichtenheft zu erstellen, das die zu Implementierenden Anforderungen enthält, um sicherzustellen das der Kunde auch das erhält was er sich vorstellt. <br> Im Zuge des Projekts sollte auch ein Abschlussbericht verfasst werden, der den Gesamtverlauf des Projekts etwas detaillierter zusammenfasst.
                </p>
                <br> <br>
                <h2>Dokumentationstool festlegen</h2>
                <hr>
                <p>Um sämtliche Dokumente einheitlich und effizient festhalten zu können musste ein Dokumentationstool festgelegt werden, das dafür verwendet wird. Dort haben wir uns letztendlich dafür entschieden alle Dokumente und besonders den Abschlussbericht mihilfe von LaTeX zu schreiben. LaTeX ist eine Art von Markup Sprache, die viele Bibliotheken und Erweiterungen anbietet, um genau das erreichen zu können was man möchte. Im Gegensatz zu Word oder ähnlichen Editoren folgt LaTeX nicht dem Prinzip "WYSIWYG". Das bedeutet "what you see is what you get". Was du siehst, das bekommst du. In LaTeX sieht es im ersten moment eher so aus als würde man eine Programmiersprache benutzen, denn erst nach der Umwandlung des geschriebenen in ein entsprechendes Format wie PDF oder HTML wird das Ergebnis erst sichtbar. <br>
                Wir haben uns für LaTeX entschieden, weil wir in dem Abschlussbericht zu sechst an einem einzigen Dokument arbeiten sollen. Sechs unterschiedliche Word Dateien am Ende zusammenzufügen oder eine Versionskontrolle mit Word zu betreiben ist alles andere als praktisch. Doch mit LaTeX ist eine Git Versionskontrolle kein Problem, da das nicht umgewandelte geschriebene sich genauso verhält wie eine Quelltextdatei einer beliebigen Sprache.
                </p>
                <br> <br>
                <h2>Quelltextdokumentation erstellen</h2>
                <hr>
                <p>TODO
                </p>
                <br> <br>
                <h2>Gantt-Diagramm verwalten</h2>
                <hr>
                <p>TODO
                </p>
                <br> <br>
            </div>
            </div>
          </div>
    </div>
</body>
</html>